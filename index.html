<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>倾听知识的声音</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="倾听知识的声音">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="倾听知识的声音">
<meta property="og:locale" content="Chinese and English">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="倾听知识的声音">
  
    <link rel="alternate" href="/atom.xml" title="倾听知识的声音" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">倾听知识的声音</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-领导力培训" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/26/领导力培训/" class="article-date">
  <time datetime="2018-10-26T08:56:45.723Z" itemprop="datePublished">2018-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/26/领导力培训/">领导力培训</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>都说不想当将军的士兵不是好士兵，相信所有不愿意昏庸度日，有理想、有上进心的人都渴望成为一个将军吧。那你准备好去做一个将军了吗？你知道什么样的将军才算是合格的将军吗？你知道如何成为一个优秀的将军吗？成为将军后，你又将如何去面对即将遇到的挑战呢？其实归根结底就是如何发展你的领导力，顺利完成角色的转变，成为一个好的领导。</p>
<h3 id="发展领导力"><a href="#发展领导力" class="headerlink" title="发展领导力"></a>发展领导力</h3><p>那究竟什么是领导力，它和知识、技能有什么区别呢？领导力实际上是一种能力，更多指的是一些软技能，具有可迁移性，适用于任何岗位；不只局限于工作，相同的能力在生活中同样适用。知道一个人是否有能力，需要结合他的行为来看。面试中有一门方法叫做行为面试法，“根据候选人过去实际行为的事例描述来评测其胜任力，通过收集候选人提供的行为事例来预测候选人未来将会如何处理相关情况”</p>
<h3 id="角色转变与角色认知"><a href="#角色转变与角色认知" class="headerlink" title="角色转变与角色认知"></a>角色转变与角色认知</h3><p>我们有时会遇到这样的场景，领导抱怨“某某员工格局太小，视野太局限，不能从大局出发，站在自己的视角上看待问题，处理问题不够全面“。其实仔细想想，出现这样的情况很正常。处在不同的位置上，接触的人、看到的风景、处理事情的复杂度自然是不同的，当经历过许多挑战、克服过很多困难，随着经验、能力的不断提升，自然能够很好的处理一切。但是对于员工来说，他们的角色、位置、经验、资历决定了他们没有你这样的环境、没有经历过你所经历的挫折困难，没有和你相同的机会，如何能够期盼他们能成为像你一样的人，像你一样全面的考虑问题、处理事情呢？</p>
<p>在工作中我们的关注点更多的是业绩，业绩实际上是做出来的，也就是说是由行为产生的，行为的产生是需要特定环境的（不同的环境产生的行为是不一样），也就是说如果你希望这个员工能够有这样的行为，你首先得给他这个机会，创造这样的环境。只有机会当然是不够的，能够产生这个行为少不了知识和技能的支撑。除了这些客观因素，还得考虑个人的想法，什么事情对他来说是最重要的 ，他愿不愿意去承担这个责任。</p>
<p>大多数人在角色转变的过程中会体会到各种不适。例如从技术工作者转变成管理者的时候，会很排斥那些沟通、管理工作，认为这些琐碎的事情占据了自己大部分时光，非常怀念之前能够专注研究技术、写代码的时光，工作的很不顺心。产生这样结果的根因就是他的角色和角色认知是分离的。他的角色是一个领导，需要完成作为领导应该尽的责任，但是在他的认知中他依旧是一个技术人员，更加喜欢花时间去专研各种前沿的技术。当角色和角色认知冲突的时候，工作自然就不会顺利。这个时候就需要一个自上而下的自我反思了。知道了什么对于作为领导最为重要？知道应该学习哪些知识和技能让自己能够胜任这个新的角色？知道作为一个领导在什么样的场合应该做什么，这样才是对角色的正确认知。当然不可避免你会失去一些，例如那些无人打扰的时光，毕竟有得必有失，有舍才有得。</p>
<h3 id="管理者角色"><a href="#管理者角色" class="headerlink" title="管理者角色"></a>管理者角色</h3><p>我们常见的管理者可能会是以下几种类型</p>
<ul>
<li>Expert：某一方面技术能力很强，是某个领域的专家</li>
<li>Manager：发布任务，设定目标，保证目标的达成</li>
<li>Coach： 发展他人、团队的能力</li>
<li>Leader：用正确的方式达成目标，激励让人想干活</li>
</ul>
<p>一个领导包含是其中的一种或是几种特质。前两种主要是在做事，后两种主要是在管理人。这几种类型的领导都会有自己的局限。</p>
<ul>
<li>Expert：可能因为自身出色的能力，技术专长吸引到许多员工，但是潜在问题是，可能员工学会了就会离开，留下的都是想要依赖领导但是自身能力不太强的。</li>
<li>Manager：用你的职权去领导员工，虽然简单，但是不会长久，会有员工阳奉阴违</li>
<li>Coach：也许会因为你能够帮忙发现他的不足，帮助他进步留下来。</li>
<li>Leader：因为和你一起工作很开心才会留下来</li>
</ul>
<p>那么你可能会问“到底什么样的领导才是好的领导，我到底要戴上面哪几顶帽子呢？”。这个自然是因人而异，戴什么样的帽子取决你想成为什么样的领导。可以结合自己的特点、专长，辅以角色认知模型，确定你自己的领导风格。</p>
<h3 id="管理挑战"><a href="#管理挑战" class="headerlink" title="管理挑战"></a>管理挑战</h3><p>从个人贡献者转变成领导者，自然而然会遇到许多的管理挑战：</p>
<ul>
<li>组员能力不足，如何提升</li>
<li>个人能力提升</li>
<li>精准的判断出员工的强弱项</li>
<li>了解员工的发展期望</li>
<li>引导出员工的真实想法</li>
<li>激励员工/点燃员工</li>
<li>树立影响力、权威（尤其是对资深老员工，对客户）</li>
<li>管理底线/管理选择</li>
<li>……</li>
</ul>
<p>想要克服这些管理挑战，需要我们能够提升多方面的能力，例如有好的沟通技巧；能够知人善用；能够辅导员工，发现他们的不足并帮助提升；能够持续不断的给员工反馈，让它成为工作中的一部分。</p>
<h3 id="管理始于沟通"><a href="#管理始于沟通" class="headerlink" title="管理始于沟通"></a>管理始于沟通</h3><p>想要做好管理，好的沟通技能必不可少。那什么是沟通呢？它是信息的双向流动，是思想、感情的传递与反馈。我们工作生活中遇到的很多挫折都是因为沟通不到位导致的，那么常见的沟通问题有哪些？</p>
<h4 id="认知偏差"><a href="#认知偏差" class="headerlink" title="认知偏差"></a>认知偏差</h4><p>看同一幅画，大家看到的画面是不一样；品味同一篇文章，得到的体会是不一样；吃同一道食物，味觉的刺激也是不一样的。当站的角度不同，关注点不一样的时候，看到的场景自然不一样，这并什么没有对错之分。因为存在视觉盲点，看到的世界有一部分是脑补出来的。一旦发生分歧的时候，人们通常并不会意识到可能是认知偏差导致的，反而会下意识的维护自己、反驳别人。<br>世界是客观的，认知的世界是主观的，人和人互动实际上是两个主观世界的互动。那么如何克服认知偏差呢？</p>
<ul>
<li>包容心，你的包容度和你能管理多少员工成正比。要认识到人与人之间没有好坏，只有不同</li>
<li>当改变不了别人的时候，只能改变自己</li>
</ul>
<p>那究竟什么是有效的沟通是呢？总结以往的经验，<br>有效的沟通：总是能够达到沟通的目的，沟通的过程中参与人员能够做到仔细倾听、良好互动、彼此尊重，无效的沟通刚好相反。<br>无效的沟通：被动参与/下命令，沟通过程中充斥着指责、推诿，沟通完了没有任何结论/行动计划</p>
<p>通过上述信息，你会发现人际互动是有两种需求的</p>
<ul>
<li>个人需求（心情）：每个人在工作和互动式的“人性”的需求</li>
<li>实际需求（事情）：希望通过互动实现的目标</li>
</ul>
<p>想要做有效的沟通，你需要满足这两种需求，既关注人，也要落实到事。</p>
<h4 id="沟通障碍"><a href="#沟通障碍" class="headerlink" title="沟通障碍"></a>沟通障碍</h4><p>产生沟通障碍最常见的原因有：听不到位、缺乏参与、无效表达。</p>
<ol>
<li>听不到位</li>
</ol>
<p>沟通达不到预期效果最重要原因之一就是听不到位。要么是没有认真听，错失重要的信息；要么是因为认知偏差没有理解对方说的意思，那么结果自然达不到预期；要么就是只听了事情本身，没有听到对应的情绪、心情，这样可能事情完成了，但是长此以往不利于团队的管理。</p>
<p>聆听小秘诀CAR</p>
<ul>
<li>C(concentrate)：专注集中，尊重对方的发言</li>
<li>A(Acknowledge)：以自己的语言复述对方所表达的意思；在复述后通过澄清与对方确认理解（例如：你刚才提到了xxx，你的意思是xxx，是这样的吗？）</li>
<li>R(React) 回应情绪。聆听，除了关注事件本身，也应该关注讲述人的情绪，满足人际互动的两种需要，保持同理心。同理 ！= 同情/同意/比惨/给建议/搞调查。同理 = 回应事实（我观察到你最近经常加班）+ 表达感受（你一定会觉得很累）</li>
</ul>
<ol start="2">
<li>缺乏参与</li>
</ol>
<p>另外一种常见的沟通障碍就是缺乏参与，沟通是信息的双向流动，需要有思想的碰撞，缺乏互动的沟通只能算是单方面通知。如果以下命令的方式或是参与方被动参与，很难达到预期沟通的效果。那么如何提高参与性呢？答案就是提问，通过提问能够收集信息、了解真相；澄清疑虑、核对想法；拓展思维、鼓励参与。</p>
<p>“下君-尽己之力，中君-尽人之力，上君-尽人之智” — 韩非子</p>
<p>作为管理者就要做到能够集众人的智慧解决问题，提问就是收集信息，促进思考最好的方式之一。</p>
<p>问题的两大类型：</p>
<ul>
<li>封闭式问题（是或者否或者只有几种固定的回答）</li>
<li>开放式问题</li>
</ul>
<p>用开放式问题提问能够激发参与者思考。</p>
<ul>
<li>WHAT（你的困难是什么？可能遇到的困难/挑战/障碍？）</li>
<li>WHY（什么原因你会这样建议？你这样建议的理由？）</li>
<li>HOW（你打算如何开始/进行？要怎么做？下一步要怎么做才能有效的面对现状？）</li>
<li>WHEN（你认为什么时候可以完成？我们合适开始进行？）</li>
<li>WHO（谁可以帮助？哪些人可以进入这个项目计划？可以从谁那里获取资源/协助？）</li>
</ul>
<p>当然提问也需要有一些注意事项，例如问题不要过于复杂、尽量简单；不要过于发散，运用跟进式问题；要尊重对方，有敏锐度，不要问隐私性问题；问问题不要尖锐、带强迫性，不要激发对方的防御心</p>
<ol start="3">
<li>无效表达</li>
</ol>
<p>另外一个非常重要的沟通技巧就是“说”，你可能不以为然，说话谁不会说呢。但是很多沟通不到位的原因其实是说不到位。说是一个信息传达、坦诚分享、建立信任的过程。仅仅是提出意见、建议是不够的，还要适度的分享这么做的原因、理由，自己的感受、想法。如果只是提出意见，不告诉这么做的理由，大家可能会自行脑补为什么你要这么做，那么认知偏差就产生了。</p>
<p>破除常见的沟通障碍，那我们来看看一个好的沟通、互动流程是什么样的。</p>
<ul>
<li>定：定方向，明确沟通的目的以及重要性、为什么会有这次沟通谈话</li>
<li>理：理情况，理清当前的事实，有哪些问题、疑虑，相互交换信息</li>
<li>想：想方案，针对当前的问题有哪些解决方案，需要什么样的支持，需要哪些资源等等</li>
<li>明：明做法，制定出行动计划，如何进行后续的追踪，发生变化如何应对</li>
<li>做：做总结，总结这次沟通的要点，给予信心/鼓励</li>
</ul>
<h3 id="分派任务，获取承诺"><a href="#分派任务，获取承诺" class="headerlink" title="分派任务，获取承诺"></a>分派任务，获取承诺</h3><p>作为团队管理者，不代表你要事事亲为，如果你这样做了，只会焦头烂额。分派任务、授权就变的至关重要。在分派任务前需要明确这次任务期待的结果是什么，花费的成本、预计完成的时间、验收的条件等等。同时需要选择合适的人选。这个需要结合两方面考虑，一是客观条件：完成这个任务需要的知识、经验、能力；工作量有多少；任务的重要、紧急程度。二是个人意愿：这个人所具备的知识、经验、能力；他个人的发展意愿、兴趣点；他是否有时间，如果交给他有什么风险，有什么地方不合适。综合两方面考虑选择最合适的人选，“把最合适的人放在合适的位置上”，然而现实中是很难实现的。</p>
<p>最常见的问题有以下几种：</p>
<ul>
<li>不会做：候选人缺乏知识/经验/技术/能力</li>
<li>不能做：候选人缺乏资源/时间/授权/精力</li>
<li>不愿做：候选人缺乏意愿/动机/信息/兴趣</li>
</ul>
<p>这就需要具体问题具体分析了。不会做那我们给他创造尽可能多的机会，让他快速的学会所需的知识，技能；不能做我们可以帮助他调配资源，协调他手头上的工作任务的优先级；不愿意做可以去沟通了解他的真实想法，给他激励。</p>
<p>同样定、理、想、明、做也适用于职责分工互动流程。</p>
<ul>
<li>定方向：要分配什么任务给对方，为什么要做这个工作，为什么选择他做这个工作</li>
<li>理情况：说明任务职责，时间要求，期待的结果；了解对方对任务的担心和顾虑</li>
<li>想方案：如何解决对方的担心、顾虑；提供什么样的建议</li>
<li>明做法：明确后续的行动方案、步骤；确定所需要的资源；如何追踪、跟进、衡量任务的进展</li>
<li>做总结：总结讨论的要点，确认对方的信息，获取对方的承诺。</li>
</ul>
<p>许多授权失败的案例都是源于没有进行有效的追踪。</p>
<p>“人们不会做你希望的，只会做你检查的。如果你强调什么，你就检查什么。你不检查就等于不重视” —郭士纳。</p>
<p>运用有效的追踪方法，利用现成的多种渠道，确定追踪的频率并且根据情况实时的调整，鼓励对方主动承担任务的进展汇报、反馈工作，这样才可以保质保量确保任务的顺利进行。</p>
<h3 id="管理精于辅导"><a href="#管理精于辅导" class="headerlink" title="管理精于辅导"></a>管理精于辅导</h3><p>管理团队实际上是一个不断发现问题、解决问题的过程。成功型领导能够防患于未然，在关键的时间节点未雨绸缪将问题扼杀在摇篮里。但更多的是改进型领导，在团队出现问题或是发现征兆的时候，及时介入，辅导员工，解决问题，避免更大的影响。<br>有两类常见的问题，一类是工作成果不佳：工作结果在质量、数量、准时率或是成本控制上面表现的低于要求标准；另一类是不良的工作方法或是习惯对员工或是团队的绩效、士气产生了负面的影响。</p>
<p>诊断问题的流程：</p>
<ol>
<li>发现征兆</li>
</ol>
<p>作为管理者发现一些不好的征兆（绩效不佳、行为不良、能力不足、动力不高、态度不对），一定不要轻易下结论，提防陷阱，避免误判，常见的陷阱：</p>
<ul>
<li>过多假设：没有事实根据，凭借猜测作出各种假设。例如：某个同事最近心情不佳，猜测他是不是和其他同事闹矛盾了，可能实际情况是是他家里孩子生病了。</li>
<li>严苛效应：要求过高，过于严苛，最常见的场景就是：某某人这么简单的事情都做不好，要是我的要半个小时就做完了。以要求自己的程度要求别人，更甚的是用自己都做不到苛求别人</li>
<li>近期效应：最近表现不佳，就认为他一直表现不好</li>
<li>以偏概全：某个人对他的反馈不好，就认为他的能力有问题</li>
</ul>
<ol start="2">
<li>收集信息</li>
</ol>
<p>避免自己掉入到陷阱，对其他人作出误判，需要从多元管道收集信息，了解当事人的工作成果、行为展现，还有哪些问题有疑义、有待澄清。当然收集信息的渠道需要尽可能多，例如获取各种统计报表、核查记录，书面记录， 获取主管、同事、客户等等人的反馈，获取当事人自我评价记录，尽可能的全面。而且对当事人行为描述反馈要基于事实，运用STAR。</p>
<ol start="3">
<li>检验原因</li>
</ol>
<p>运用有效的分析工具方法找出问题点，找出问题的关键原因，例如是当事人不会做、不能做还是不想做。</p>
<ol start="4">
<li>做出判断</li>
</ol>
<p>找出问题的多重原因之后，选择优先级最高、影响最大的优先解决，找出可能的解决方案，准备和当事人的沟通方案。</p>
<h3 id="管理成于反馈"><a href="#管理成于反馈" class="headerlink" title="管理成于反馈"></a>管理成于反馈</h3><p>反馈在工作中至关重要，除了能够增加与员工的互动，提升信任度，更能够帮助员工正确的认识自己，了解自己的优势与劣势。</p>
<p>有效的反馈需要具备以下几点：</p>
<ul>
<li>及时：反馈一定要及时，这样便于当事人及时作出改进；如果当事人不认可也可以及时分析问题原因，减少误解</li>
<li>平衡：不要只给负面的反馈，正面的反馈的影响同样也是巨大的，正向的行为需要不断的强化，这是激励他人的一个好的方式。负面的反馈帮助员工发现自己的不足，不断提升自己</li>
<li>明确：反馈一定要是基于事实的，真诚而具体的，不要泛泛而谈</li>
</ul>
<p>给予反馈的过程中需要仔细聆听对方的看法、确保理解，需要尊重肯定对方，而不是持批判的态度，如果能够适当的给予一些建议更好。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论你是已经行进在领导力之路上，还是你即将开启你的领导力之路，从现在开始反思自己的角色认知模型，从内心深处认识到你究竟想成为一个什么样的领导，不断朝着目标前进。了解沟通的重要性，承认认知偏差，破除常见的沟通障碍，满足人际互动的两种需要，完成有效的沟通。知人善用，给员工创造成长、进步的机会。当发现团队存在问题的时候，谨慎处理，不要步入陷阱、提防误判，作出有效的辅导。了解反馈的力量，让它成为工作中必不可少的一部分。当你具备这些能力的时候，你会发现它不仅影响了你的工作，将它迁移到生活中，也同样适用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/26/领导力培训/" data-id="cjnpsyddb000zbmkjswfhhpfb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-security-knowledge" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/security-knowledge/" class="article-date">
  <time datetime="2018-09-13T07:07:06.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/security-knowledge/">security knowledge</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常见的安全问题"><a href="#常见的安全问题" class="headerlink" title="常见的安全问题"></a>常见的安全问题</h1><p>DVWA(Damn Vulnerable Web App) 是一个php/mysql的web application，非常脆弱，非容易被攻击。它的主要目的是帮助安全专家搭建一个合法的环境，测试他们的技能，了解web app security。</p>
<p><a href="http://www.dvwa.co.uk/" target="_blank" rel="noopener">http://www.dvwa.co.uk/</a></p>
<p><a href="https://hub.docker.com/r/vulnerables/web-dvwa/" target="_blank" rel="noopener">https://hub.docker.com/r/vulnerables/web-dvwa/</a></p>
<h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><p>用户的输入被程序当成指令的一部分并执行</p>
<h4 id="案例一：查看用户信息"><a href="#案例一：查看用户信息" class="headerlink" title="案例一：查看用户信息"></a>案例一：查看用户信息</h4><p><img src="/var/folders/7l/8wdbfr7n0z7bwk3vs7rhgzpr0000gn/T/abnerworks.Typora/image-20180824103557146.png" alt="image-20180824103557146"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name, last_name from users where user_id = &apos;1&apos;</span><br></pre></td></tr></table></figure>
<p><img src="/var/folders/7l/8wdbfr7n0z7bwk3vs7rhgzpr0000gn/T/abnerworks.Typora/image-20180824103818237.png" alt="image-20180824103818237"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在输入框中输入&apos; or 1=&apos;1</span><br><span class="line">select first_name, last_name from users where id = &apos;&apos; or 1=&apos;1&apos;</span><br></pre></td></tr></table></figure>
<h4 id="案例二：-登陆功能"><a href="#案例二：-登陆功能" class="headerlink" title="案例二： 登陆功能"></a>案例二： 登陆功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入用户名 Alice</span><br><span class="line">输入密码 123456</span><br><span class="line">数据库实际执行:</span><br><span class="line">Select * from admin Where username = &apos;Alice&apos; AND password = &apos;123456&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入用户名 &apos; or &apos;a&apos; = &apos;a</span><br><span class="line">输入密码 &apos; or &apos;a&apos; = &apos;a</span><br><span class="line">数据库实际执行：</span><br><span class="line">SELECT * from admin WHERE username = &apos;&apos; or &apos;a&apos; =&apos;a&apos; AND password = &apos;&apos; or &apos;a&apos; = &apos;a&apos;</span><br></pre></td></tr></table></figure>
<h3 id="SQL-注入的分类"><a href="#SQL-注入的分类" class="headerlink" title="SQL 注入的分类"></a>SQL 注入的分类</h3><ul>
<li><p>参数类型</p>
<ul>
<li><p>数字型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://victim.com/user?id=1                  200 OK</span><br><span class="line">http://victim.com/user?id=1&apos;                 400 BAD REQUEST</span><br><span class="line">http://victim.com/user?id=1 and 1=1          200 OK</span><br><span class="line">http://victim.com/user?id=1 and 1=2          404 NOT FOUND</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://victim.com/user?name=a                 200 OK</span><br><span class="line">http://victim.com/user?name=a&apos;                 400 BAD REQUEST</span><br><span class="line">http://victim.com/user?name=a&apos;and &apos;a&apos;=&apos;a          200 OK</span><br><span class="line">http://victim.com/user?name=a&apos;and &apos;a&apos;=&apos;b          404 NOT FOUND</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>服务器返回结果</p>
<ul>
<li><p>有回显的注入</p>
</li>
<li><p>有错误提示的注入</p>
</li>
<li><p>盲注（攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知）</p>
<ul>
<li>基于布尔的盲注</li>
</ul>
<p>布尔值True或是False，也就是说它只会根据你的注入信息返回True或是False，也就没有了之前的报错信息。</p>
<p><img src="/var/folders/7l/8wdbfr7n0z7bwk3vs7rhgzpr0000gn/T/abnerworks.Typora/image-20180824154222855.png" alt="image-20180824154222855"></p>
<ul>
<li>基于时间的盲注</li>
</ul>
<p>界面返回值只有一种true，无论输入任何值，返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。</p>
</li>
</ul>
</li>
</ul>
<h4 id="SQL-注入的危害"><a href="#SQL-注入的危害" class="headerlink" title="SQL 注入的危害"></a>SQL 注入的危害</h4><p>导致攻击者执行任意的SQL命令</p>
<ul>
<li>更改查询语句的返回结果，从而绕过某些限制</li>
<li>数据库存储的敏感信息泄露</li>
<li>执行任意系统命令，比如通过调用mysql的system函数</li>
<li>读取任意文件，比如通过调用mysql中的load_file函数</li>
<li>写文件操作，比如调用mysql中的select….into outfile…..</li>
</ul>
<h3 id="SQL注入防御措施"><a href="#SQL注入防御措施" class="headerlink" title="SQL注入防御措施"></a>SQL注入防御措施</h3><ul>
<li><p>对输入进行过滤，不接受某些特殊字符例如’, or, and ==&gt; 难以满足允许特殊字符的业务场景</p>
</li>
<li><p>输入验证，验证输入的合法性，例如有些场景只允许输入数字，如果不满足则拒绝 ==&gt;场景过多时复杂度变高，而且某些场景依然无法穷举</p>
</li>
<li><p>参数化查询</p>
<ul>
<li>数据库提供参数化查询的功能用于将代码和数据分离</li>
<li>当需要执行数据库查询语句时，用参数化查询来防范SQL注入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String query = &quot;SELECT id, frstname, lastname FROM authors WHERE forename = ? and surname = ?&quot;;</span><br><span class="line">PreparedStatement pstmt = connection.prepareStatement( query );</span><br><span class="line">pstmt.setString( 1, frstname );</span><br><span class="line">pstmt.setString( 2, lastname );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>input: 192.168.6.116; cat /etc/passwd</p>
<p><img src="/var/folders/7l/8wdbfr7n0z7bwk3vs7rhgzpr0000gn/T/abnerworks.Typora/image-20180824165802723.png" alt="image-20180824165802723"></p>
<h3 id="其他的注入攻击"><a href="#其他的注入攻击" class="headerlink" title="其他的注入攻击"></a>其他的注入攻击</h3><p>常见安全问题清单<br>更新于：2018-07-18</p>
<p>1. 调试用的接口是否已经从发布中去除？    2<br>1.1 框架自带的调试接口    2<br>1.2 开发人员预留的调试接口    3</p>
<ol start="2">
<li><p>文件上传功能安全    3<br> .1 文件上传功能是否做了文件真实类型校验？    3<br> .2 文件上传功能是否对上传后的文件重命名？    4<br> . 敏感函数的输入是否经过处理？    5<br> . 是否已经在响应中添加了security header?    5<br> .1 X-Content-Type-Options    5<br> .2 X-XSS-Protection    6<br> .3 Strict-Transport-Security    6<br> .4 X-Frame-Options    6<br> . HTTP非200响应的页面是否已经做了统一配置？    6<br> . 响应头里是否过滤了敏感信息？    7<br> . 用户名是否可被枚举？    7<br> . 登录功能可被暴力破解？    8<br> . API权限校验是否充足？    8</p>
</li>
<li><p>调试用的接口是否已经从发布中去除？<br>1.1 框架自带的调试接口<br>案例<br>Spring Boot框架提供一系列接口方便开发人员对应用进行监控和调试，比如：/loggers、/metrics、/heapdump、/autoconfig等，并且默认是公开的访问权限。如果开发人员在上线之前没有移除掉这一类接口，会被攻击者利用，从中得到应用的敏感信息。</p>
</li>
</ol>
<p>如何检查<br>如果使用了Spring框架，请访问以下提供的敏感接口，确保没有敏感信息返回<br>actuator<br>auditevents<br>autoconfig<br>beans<br>configprops<br>dump<br>env<br>flyway<br>health<br>info<br>loggers<br>liquibase<br>metrics<br>mappings<br>shutdown<br>trace<br>docs<br>heapdump<br>jolokia<br>logfile<br>swagger-ui.html<br>如果使用了tomcat，请访问以下提供的敏感接口，确保没有敏感信息返回<br>examples<br>manager<br>host-manager<br>docs</p>
<p>如何修复<br>在应用发布前将调试接口移除。<br>1.2 开发人员预留的调试接口<br>案例<br>项目组人员为了测试方便而创建的一些临时用的调试接口，用以生成token、清楚缓存等作用。如果开发人员在上线之前没有移除掉这一类的接口，会被攻击者利用以执行一些非法操作。</p>
<p>如何检查<br>请在项目上线之前和开发团队内部确认调试用的接口已经被移除。</p>
<p>如何修复<br>在应用发布前将调试接口移除。</p>
<ol start="2">
<li>文件上传功能安全<br>2.1 文件上传功能是否做了文件真实类型校验？<br>案例1：应用中有上传文档扫描件的功能，但是没有对文件的上传类型做校验。攻击者发现可以上传恶意文件到应用服务器上。</li>
</ol>
<p>案例2：应用中有上传文档扫描件的功能，并且检查了上传文件的后缀名必须是“.pdf”。攻击发现可以上传将后缀名更改为“.pdf”的恶意文件到应用服务器上。</p>
<p>案例3：应用中有上传文档扫描件的功能，并且检查了上传文件的Content-Type必须是“application/pdf”。攻击发现可以上传将Content-Type更改为“application/pdf”的恶意文件到应用服务器上。</p>
<p>如何检查<br>对任何有文件上传功能的接口进行检查，比如上传文档扫描件、上传个人头像等接口。尝试用目标接口上传：<br>类型合法的文件，将后缀名更改为非法类型，如果可以上传成功则需要对上传接口进行修复处理。<br>类型非法的文件，将后缀名更改为合法的后缀名，如果可以上传成功则需要对上传接口进行修复处理。</p>
<p>如何修复<br>在文件上传接口的处理逻辑中：<br>对文件名进行白名单校验，如果文件名含有白名单之外的字符，则返回错误。<br>对文件后缀名进行白名单校验，如果文件后缀名不在白名单内，则返回错误。<br>使用Apache Tika对文件真实类型做校验，如果真实类型不在白名单内，则返回错误。<br>2.2 文件上传功能是否对上传后的文件重命名？<br>案例1：应用中有上传文件的功能，但是未对上传后的文件进行重命名。攻击者上传精心构造的文件名的文件，利用容器已知的解析漏洞执行攻击。</p>
<p>案例2：应用中有上传文件的功能，并且使用拼接文件名的方式创建文件夹。攻击者上传文件的文件名为“test/test.jpg”，创建了test目录；或者攻击者上传文件的文件名为“../../test.jpg”，将文件上传到非法区域。</p>
<p>如何检查<br>对任何有文件上传功能的接口进行检查，比如上传文档扫描件、上传个人头像等接口。尝试用目标接口上传文件，并查看响应中的文件上传后是否经过重命名。</p>
<p>如何修复<br>后端API在保存文件前先对文件进行重命名，比如生成随机的uuid加上合法的后缀作为文件名。</p>
<ol start="3">
<li>敏感函数的输入是否经过处理？<br>案例<br>应用有生成报告的功能，接收请求中传入的name等参数，生成以“name.pdf”为名字的pdf文档供下载。后端API的实现调用了Runtime.getRuntime().exec()函数，并传入了name参数，以执行操作系统命令的方式来生成报告。攻击者可以构造name参数为“report; mkdir test”的请求，使得后端API调用exec函数执行命令的时候执行多余的恶意的命令（案例中该恶意命令为mkdir test）。</li>
</ol>
<p>如何检查<br>审查应用中是否用到了Runtime.getRuntime().exec()函数，以及传入的参数是否未经过滤直接由用户输入得到，如果是这样，那么在参数中加入命令分隔符尝试注入恶意命令，并从日志或者响应中观察恶意命令是否执行成功。</p>
<p>如何修复<br>在使用到Runtime.getRuntime().exec()函数的地方，对由用户传入的输入进行白名单过滤，只允许传入合法的参数。</p>
<ol start="4">
<li>是否已经在响应中添加了security header?<br>说明<br>浏览器有一些自带的功能特性，可以帮助防御部分常见的安全问题。为了达到这一效果，我们需要在返回的http头部添加部分与安全相关的header并对其作出正确的配置。这些security header如下：<br>4.1 X-Content-Type-Options<br>作用：X-Content-Type-Options响应头告诉浏览器，是否启用MIME嗅探来猜测资源的类型以及解析和执行其中的内容。<br>推荐配置：X-Content-Type-Options: nosniff<br>4.2 X-XSS-Protection<br>作用：X-XSS-Protection响应头告诉浏览器，当检测到疑似XSS攻击的恶意代码时，阻止页面继续渲染。<br>推荐配置：X-XSS-Protection: 1; mode=block<br>4.3 Strict-Transport-Security<br>作用: HTTP Strict Transport Security (通常简称为HSTS) 响应头是用来指示浏览器只能通过HTTPS访问当前资源，禁止HTTP方式。<br>推荐配置：Strict-Transport-Security: max-age=31536000 ; includeSubDomains<br>4.4 X-Frame-Options<br>作用：X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。<br>推荐配置：根据业务上下文选择最佳配置（DENY、SAMEORIGIN、ALLOW-FROM）。如果不需要被嵌入到其他网页中，则推荐配置为X-Frame-Options: DENY。</object></iframe></li>
</ol>
<p>如何检查<br>检查HTTP响应中是否包含提及的security headers。</p>
<p>如何修复<br>可以在容器，或者代码框架中添加配置相关的security headers。</p>
<ol start="5">
<li>HTTP非200响应的页面是否已经做了统一配置？<br>案例1：应用的HTTP 500错误响应暴露了错误堆栈，攻击者可以从中搜集到一些技术信息，利于发动进一步攻击。</li>
</ol>
<p>案例2：应用的HTTP 404错误响应暴露了nginx的版本号，攻击者可以利用该版本nginx存在的漏洞发动进一步攻击。</p>
<p>如何检查<br>制造404响应和500响应的错误，查看返回的结果里是否包含敏感信息。</p>
<p>如何修复<br>对错误页面做统一的配置，以非敏感的内容提示用户。</p>
<ol start="6">
<li>响应头里是否过滤了敏感信息？<br>案例<br>响应头中包含X-Application-Context：api-gateway:prod:8080、Server: nginx/1.11.3等内容，攻击者可以从中搜集到一些技术信息，利于发动进一步攻击。</li>
</ol>
<p>如何检查<br>查看应用的响应头是否包含技术相关的敏感信息，比如版本号，端口号，内网IP地址等。</p>
<p>如何修复<br>在容器或者API中进行配置，屏蔽掉响应头中的敏感信息。比如nginx的配置文件中加上“server_tokens off;”可去掉响应头中nginx的版本信息。</p>
<ol start="7">
<li>用户名是否可被枚举？<br>案例<br>在登录界面输入正确的用户名和错误的密码，返回结果为：“用户名不正确”。输入错误的用户名和错误的密码，返回结果为：“用户名或密码不正确”。由于两种情况下返回的错误信息不同，导致攻击者可以枚举出系统中存在的用户名。</li>
</ol>
<p>如何检查<br>在登录界面尝试以下情况：<br>正确的用户名和密码<br>错误的用户名和错误的密码<br>对比http响应中的结果。如果结果不一致，则存在用户名可被枚举的问题。</p>
<p>如何修复<br>不管是用户名错误还是密码错误，登录失败的错误信息需要保持一致。</p>
<ol start="8">
<li>登录功能可被暴力破解？<br>案例<br>由于登录失败次数没有任何限制，攻击者可以用正确的账号和不同密码的组合尝试枚举出正确的登录凭证。</li>
</ol>
<p>如何检查<br>直接调用登录API尝试正确的用户名和错误的密码，尝试多次，观察是否有错误次数的限制。特别注意需要直接调用后端API，不要仅仅只在前端尝试，因为有可能前端做了次数限制，但是后端却没有做任何检查。</p>
<p>如何修复<br>对登录失败次数做限制。登录失败超过N次后锁定该账户M分钟，或者需要输入正确的验证码才能继续尝试登录。N建议为5，M建议为20。</p>
<ol start="9">
<li>API权限校验是否充足？<br>案例1：某些本该做权限校验的API并未做任何权限控制，攻击者可以直接调用该API进行越权操作。</li>
</ol>
<p>案例2：POST /order/{id}/comment接口提供为自己的订单添加备注的功能。该API校验了请求者需要有customer的role，但是并没有校验该customer与order的所属权。导致恶意的customer可以调用该接口给不属于自己的订单添加备注。</p>
<p>如何检查<br>梳理清楚API的权限设定，从以下两个方面测试是否有不足的权限校验发生：<br>平行越权：权限类型不变，权限ID改变；如：同是普通用户，其中一个用户可查看其它用户信息。<br>垂直越权：权限ID不变，权限类型改变；如普通用户可使用管理员权限进行操作。<br>交叉越权：权限类型改变，权限ID也改变。</p>
<p>如何修复<br>梳理清楚API的权限设定，为API做充分的权限校验。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/13/security-knowledge/" data-id="cjnpsydd9000ubmkjs1hc5iag" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-商业模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/08/商业模式/" class="article-date">
  <time datetime="2018-08-08T07:25:48.000Z" itemprop="datePublished">2018-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/商业模式/">商业模式 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>盈利模式</p>
<ul>
<li>广告</li>
<li>用户打赏</li>
<li>电商嵌入</li>
<li>内容收费</li>
</ul>
<p>电子商务模式：<br>B代表企业， C代表个人（终端消费用户）， O代表线上、也可以代表线下， 2是利用电子信息手段建立的连接两个主体的商务解决方案。</p>
<ul>
<li>B2B：企业对企业，例如微软做面向企业级用户的业务可以叫B2B；给线下的零售商店批发货物也叫B2B</li>
<li>B2C： 微软面向个人用户的业务叫B2C；某某旗舰店出售一个物品给个人也叫B2C</li>
<li>C2C： 个人淘宝点向用户出售物品叫C2C；个人商品的二手买卖<br>O2O：体现了线上与线下、比特与原子、虚拟与现实的结合思维。显著特点是：打通了线上与线下，完成了消费、享受这一连串动作，因此所有的线上B2B/B2C/C2C，也就是电子商务其实都可以认为是O2O</li>
</ul>
<p>商业模式：</p>
<ul>
<li>平台型： 模式是提供给个人或者企业进行开店交易的平台，通过佣金、服务费、广告费、增值服务等盈利</li>
<li>垂直型：<br>主要是经营单一类目，垂直电商有一个很重要的特性就是销售的商品都是自营，这类公司一般是获得了某些品牌的代理权或者经销权，通过赚取差价盈利，比如主做鞋的优购、做服装的有货、做酒类的酒仙网等</li>
<li>混合型：<br>垂直电商发展到一定程度进行类目扩张，自营+店铺，自行原来的优势类目，扩大市场份额，赚取差价；引入更多类目的品牌商入驻开店，收取用尽佣金、服务费、广告费</li>
<li>导购型：<br>做流量分发，赚取交易佣金</li>
<li>内容型：</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/08/商业模式/" data-id="cjnpsydd7000rbmkjoapdonga" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-shell-script" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/07/shell-script/" class="article-date">
  <time datetime="2018-08-07T08:19:56.000Z" itemprop="datePublished">2018-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/07/shell-script/">shell script</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="判断参数长度以及参数中是否存在某字符串"><a href="#判断参数长度以及参数中是否存在某字符串" class="headerlink" title="判断参数长度以及参数中是否存在某字符串"></a>判断参数长度以及参数中是否存在某字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">if [ $&#123;#@&#125; -ne 0 ] &amp;&amp; [ &quot;$&#123;@#&quot;--help&quot;&#125;&quot; = &quot;&quot; ]; then</span><br><span class="line">  printf -- &apos;...help...\n&apos;;</span><br><span class="line">  exit 0;</span><br><span class="line">fi;</span><br></pre></td></tr></table></figure>
[${#@} -ne 0],计算参数长度，参数长度不为0时检查是否存在–help标记<br><br><br>### stty(set tty)<br>stty: set tty, 用于注册和修改当前注册的终端的通信参数。UNIX系统为键盘的输入和终端的输出提供了重要的控制手段，可以通过stty命令对特定终端或通信线路设置选项。<br><br>查看当前终端的设置情况:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stty -a</span><br><span class="line">&lt;!-- output --&gt;</span><br><span class="line">speed 38400 baud; 26 rows; 163 columns;</span><br><span class="line">lflags: icanon isig iexten echo echoe echok echoke -echonl echoctl</span><br><span class="line">	-echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo</span><br><span class="line">	-extproc</span><br><span class="line">iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel iutf8</span><br><span class="line">	-ignbrk brkint -inpck -ignpar -parmrk</span><br><span class="line">oflags: opost onlcr -oxtabs -onocr -onlret</span><br><span class="line">cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow</span><br><span class="line">	-dtrflow -mdmbuf</span><br><span class="line">cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = &lt;undef&gt;;</span><br><span class="line">	eol2 = &lt;undef&gt;; erase = ^?; intr = ^C; kill = ^U; lnext = ^V;</span><br><span class="line">	min = 1; quit = ^\; reprint = ^R; start = ^Q; status = ^T;</span><br><span class="line">	stop = ^S; susp = ^Z; time = 0; werase = ^W;</span><br></pre></td></tr></table></figure>
<p>上面实现的终端选项都可以重新配置。每种配置都有自己的名字（eg：echo），要么被设置，要么被清除（选项前面有负号-，代表被清除、禁止；没有代表被设置）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 禁止终端输出</span><br><span class="line">stty -echo;</span><br><span class="line"># 启用终端输出</span><br><span class="line">stty echo;</span><br></pre></td></tr></table></figure></p>
<h3 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a>set -e</h3><p>set -e 表示从当前位置开始，如果出现任何错误（命令失败，返回非零的退出状态，除非是迭代 &amp;&amp;, || 命令的一部分）都将触发EXIT，相反set +e表示从当前位置开始不管出现任何错误都继续执行脚本。</p>
<h3 id="使用escape-sequence-code颜色编码输出"><a href="#使用escape-sequence-code颜色编码输出" class="headerlink" title="使用escape sequence code颜色编码输出"></a>使用escape sequence code颜色编码输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf -- &apos;\033[32m SUCCESS: yay \033[0m\n&apos;;</span><br></pre></td></tr></table></figure>
<p>\033[32m就是escape sequence code， 读到\033说明后面的字符是escape sequence，会特殊处理。[32m, 32是设置终端输出颜色。</p>
<h3 id="捕捉信号trap"><a href="#捕捉信号trap" class="headerlink" title="捕捉信号trap"></a>捕捉信号trap</h3><p>如果脚本在执行过程中终止，如何处理后续的事情？例如输出错误信息。可以通过信号机制终止脚本（不是所有发送的信号都是终止信号）<br>查看信号列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kill -l</span><br><span class="line">HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2</span><br></pre></td></tr></table></figure></p>
<p>脚本接收信号后，可以：</p>
<ul>
<li>忽略信号，不执行任何操作</li>
<li>使用trap 捕捉信号，并却采取相应的操作(trap ‘command_list’ signals)</li>
<li>使用默认操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap &apos;echo you hit Ctrl-C/Ctrl-\, now exiting..; exit&apos; SIGINT SIGQUIT</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/07/shell-script/" data-id="cjnpsydd3000ibmkj6gqfvwu6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css-new-properties-introduction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/07/css-new-properties-introduction/" class="article-date">
  <time datetime="2018-08-07T01:55:56.000Z" itemprop="datePublished">2018-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/07/css-new-properties-introduction/">css new properties introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CSS Display Module (Level 3)</p>
<p>display: contents;<br>W3C status – Working Draft<br>Browser support<br>CSS Conditional Rules Module (Level 3)</p>
<p>@support(…) {…}<br>W3C status - Candidate Recommendation<br>Further reading: MDN web docs<br>CSS Overscroll Behavior Module (Level 1)</p>
<p>overscroll-behavior: contain;<br>W3C status – Unofficial<br>Browser support<br>Further reading: Take control of your scroll<br>CSS Selectors Module (Level 4)</p>
<p>:focus-within<br>W3C status – Working Draft<br>Browser support<br>Further reading: MDN web docs :focus-within, :placeholder-shown<br>The CSS Containment Module (Level 1) </p>
<p>contain: paint;<br>W3C status - Candidate Recommendation<br>Browser support<br>Further reading: CSS Containment in Chrome 52</p>
<h2 id="display-contents"><a href="#display-contents" class="headerlink" title="display: contents"></a>display: contents</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;feed&quot;&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 1&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 2&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 3&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 4&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 5&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;nested&quot;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card A&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card B&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card C&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 6&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 7&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 8&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 9&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;div class=&quot;card&quot;&gt;Card 10&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul.feed  &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ul.feed 设置了display:flex只会对其子元素ul.feed &gt; li .card 有影响，但不会影响其后代子元素，换句话说，.nested &gt; li是无法自动变成Flex项目。除了改变html 模版或是使用js，没有办法使得所有的li都会成为flex项目。</p>
<p>那么display: contents这一简单的代码实际上让元素表现得好像不存在一样。但仍然可以看到元素的后代，而且元素自身并不影响布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ul.feed  &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">.feed ul,</span><br><span class="line">.feed li &#123;</span><br><span class="line">    display: contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样所有的.card都是flex item。</p>
<h2 id="soupport-css查询特性"><a href="#soupport-css查询特性" class="headerlink" title="@soupport css查询特性"></a>@soupport css查询特性</h2><p>// 支持 display: contents的浏览器，采用的是这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@supports (display: contents) &#123;</span><br><span class="line">    .feed ul,</span><br><span class="line">    .feed li &#123;</span><br><span class="line">        display: contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .card &#123;</span><br><span class="line">        flex: 1 0 40%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@support 可以和and、or和not结合起来使用，让表达式更加的强大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@supports (display: contents) and (display: flex)</span><br></pre></td></tr></table></figure></p>
<h2 id="oversroll-behavior解决滚动链接"><a href="#oversroll-behavior解决滚动链接" class="headerlink" title="oversroll-behavior解决滚动链接"></a>oversroll-behavior解决滚动链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;chat&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;messages&quot;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 1&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 2&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 3&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 4&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 5&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 6&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 7&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 8&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 9&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;div class=&quot;message&quot;&gt;Message 10&lt;/div&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; class=&quot;input&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        ......</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>滚动聊天框中的消息列表时（.messages），滚动到消息列表末端时，可以看到页面body将开始滚动。这种效果被称为滚动链接，即Scroll Chaining。<br>解决方案：<br>1.body添加overflow:hidden<br>2.overscroll-behavior</p>
<ul>
<li>auto：其默认值。元素（容器）的滚动会传播给其祖先元素。有点类似JavaScript中的冒泡行为一样</li>
<li>contain：阻止滚动链接。滚动行为不会传播给其祖先元素，但会影响节点内的局部显示。例如，Android上的光辉效果或iOS上的回弹效果。当用户触摸滚动边界时会通知用户。注意，overscroll-behavior:contain在html元素上使用，可以阻止导航滚动操作</li>
<li>none：和contain一样，但它也可以防止节点本身的滚动效果</li>
</ul>
<h2 id="focus-within伪类选择器"><a href="#focus-within伪类选择器" class="headerlink" title=":focus-within伪类选择器"></a>:focus-within伪类选择器</h2><p>一样，但是:focus-within与其不同之处是，如果元素的任何后代元素得到焦点，它就会被匹配。这就是这个属性特别之处，因为它与CSS通常的工作方式相反，通常我们只能根据元素的祖先来选择元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将消息框折叠起来 --&gt;</span><br><span class="line">.messages &#123;</span><br><span class="line">    ...</span><br><span class="line">    max-height: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    transition: max-height 500ms; </span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- chat任何后代元素得到焦点，展开消息框 --&gt;</span><br><span class="line">.chat:focus-within .messages &#123;</span><br><span class="line">    max-height: 300px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当.chat区域内的任何内容得到焦点时，重置一下.message的max-height和padding值。请记住，一个元素必须接受键盘或鼠标事件或其他形式的输入，以便接收焦点。比如我们这个示例，点击<input>输入框就符合这个要求，可以达到我们想要的预期效果。所以当点击input，input获得焦点，也就是chat的后代元素获得焦点，消息框就展开了。<br>注意：点击除input的其他区域，消息框都没有办法展开。</p>
<p>当文本输入框得到焦点之后，除了能展开聊天框之外，还希望聊天框底下的Newsfeed变得模糊(.container)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用css选择器中的兄弟选择器 --&gt;</span><br><span class="line">.chat:focus-within ~ .container &#123;</span><br><span class="line">    filter: blur(5px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意： filter效果，这将会改变元素的层叠顺序，造成聊天框（.chat)在Newsfeed(.container)下面。所以需要显式的.chat中添加z-index的值</p>
<h2 id="placeholder-shown-伪类选择器"><a href="#placeholder-shown-伪类选择器" class="headerlink" title=":placeholder-shown 伪类选择器"></a>:placeholder-shown 伪类选择器</h2><p>::placeholder是一个伪元素（一个在DOM中并不存在的可见元素），:placeholder-shown是一个伪类选择器， 两者并不相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 新增占位符文本 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; class=&quot;input&quot; placeholder=&quot;Enter your message&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>input获得焦点的时候，placeholder不可见<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当占位符文本不可见的时候，我们可以做一些操作 --&gt;</span><br><span class="line">.input:not:(:placeholder-shown) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="探索Containment"><a href="#探索Containment" class="headerlink" title="探索Containment"></a>探索Containment</h2><p><a href="https://www.creativebloq.com/how-to/5-hot-new-css-features-and-how-to-use-them" target="_blank" rel="noopener">https://www.creativebloq.com/how-to/5-hot-new-css-features-and-how-to-use-them</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/07/css-new-properties-introduction/" data-id="cjnpsydd1000fbmkjozixqw2c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-use-grid-layout-to-implement-responsive-layout" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/use-grid-layout-to-implement-responsive-layout/" class="article-date">
  <time datetime="2018-08-06T07:40:04.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/use-grid-layout-to-implement-responsive-layout/">use grid layout to implement responsive layout</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开始使用CSS Grid之前，先明确一下几点：</p>
<ol>
<li>CSS grid不能替代flex，不能替代float。我们可以认为它们有不同的使用场景，应该将它们结合起来使用</li>
<li>flex是一维的， grid是二维的</li>
</ol>
<p>html结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;boxes&quot;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;boxes__text-wrapper&quot;&gt;</span><br><span class="line">      &lt;h2&gt;Case Study Title 1&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;A catchy description for our case study. We worked hard.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;boxes__text-wrapper&quot;&gt;</span><br><span class="line">      &lt;h2&gt;Case Study Title 2&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;A catchy description for our case study. We worked hard.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;boxes__text-wrapper&quot;&gt;</span><br><span class="line">      &lt;h2&gt;Case Study Title 3&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;A catchy description for our case study. We worked hard.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;boxes__text-wrapper&quot;&gt;</span><br><span class="line">      &lt;h2&gt;Case Study Title 4&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;A catchy description for our case study. We worked hard.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;boxes__text-wrapper&quot;&gt;</span><br><span class="line">      &lt;h2&gt;Case Study Title 5&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;A catchy description for our case study. We worked hard.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;boxes__text-wrapper&quot;&gt;</span><br><span class="line">      &lt;h2&gt;Case Study Title 6&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;A catchy description for our case study. We worked hard.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>css样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  font-family: Avenir, sans-serif;</span><br><span class="line">  margin: 2rem auto;</span><br><span class="line">  width: 95%;</span><br><span class="line">&#125;</span><br><span class="line">h2,</span><br><span class="line">p &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.boxes &gt; * &#123;</span><br><span class="line">  padding: .5rem;</span><br><span class="line">  background-color: #333;</span><br><span class="line">  color: white;</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">gap: 行与行间距，列与列间距</span><br><span class="line">grid-auto-rows： our rows to be a minimum of 120px and a maximum of auto</span><br><span class="line">*/</span><br><span class="line">.boxes &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-auto-rows: minmax(125px, auto);</span><br><span class="line">  grid-gap: .5rem; </span><br><span class="line">&#125;</span><br><span class="line">.boxes li &#123;</span><br><span class="line">  background-image:</span><br><span class="line">    linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.8)),</span><br><span class="line">    url(path/to/image);</span><br><span class="line">  background-size: cover;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* browser is 40em or larger */</span><br><span class="line">@media screen and (min-width: 40em) &#123;</span><br><span class="line">  .boxes &#123;</span><br><span class="line">    grid-template-columns: repeat(6, 1fr);</span><br><span class="line">    grid-gap: 2px;</span><br><span class="line">  &#125;</span><br><span class="line">/* 占据3行   */</span><br><span class="line">  .boxes li:nth-child(1) &#123;</span><br><span class="line">    grid-column: 1 / -1;</span><br><span class="line">    grid-row: span 3; </span><br><span class="line">  &#125;</span><br><span class="line">  .boxes li:nth-child(2) &#123;</span><br><span class="line">    grid-column: span 2;</span><br><span class="line">    grid-row: span 7;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .boxes li:nth-child(3) &#123;</span><br><span class="line">    grid-column: span 4;</span><br><span class="line">    grid-row: span 3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .boxes li:nth-child(4) &#123;</span><br><span class="line">    grid-column: span 2;</span><br><span class="line">    grid-row: span 4;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .boxes li:nth-child(5),</span><br><span class="line">  .boxes li:nth-child(6) &#123;</span><br><span class="line">    grid-column: span 2;</span><br><span class="line">    grid-row: span 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>支持旧浏览器，使用CSS查询特性@support<br>feature queries 主要包含@media、@supports和@viewport<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.your-selector &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Your Grid code */</span><br><span class="line">// 支持display: grid的浏览器，采用的是这段代码</span><br><span class="line">@supports (display: grid) &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 1fr);</span><br><span class="line">  grid-gap: 1rem 2rem;</span><br><span class="line">&#125;</span><br><span class="line">// 不支持display:grid的浏览器，采用下面这段代码</span><br><span class="line">@supports not (display: grid) &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">// 支持display: grid 和display: flex的浏览器，采用的是这段代码</span><br><span class="line">@supports (display: grid) and (display: flex)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://codepen.io/anon/pen/ZjjmOY" target="_blank" rel="noopener">https://codepen.io/anon/pen/ZjjmOY</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/use-grid-layout-to-implement-responsive-layout/" data-id="cjnpsydd4000kbmkj5q8ocbkf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-不同框架Virtual-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/不同框架Virtual-DOM/" class="article-date">
  <time datetime="2018-07-18T01:59:16.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/不同框架Virtual-DOM/">不同框架Virtual DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在许多的人认知中virtual dom的产生是为了减少对DOM的直接操作，是一种性能和执行效率上的提升。真实的DOM包含的太多的属性参数，说到底就是用一个简单的对象（只会存储一些重要的参数）去代替一个复杂的对象。其实不只是这样（对于一些比较简单的dom结构来说，直接修改dom可能效率更高。但是庞大复杂的页面结构，效率更高），除了减少DOM操作的消耗，它在原始的JS编程上更进一步，做了一个抽象（JS操作DOM的抽象）和封装，我们不用关心底层浏览器提供的DOM，而是让virtual dom去操作，这实际上是效率、通用性上的平衡。</p>
<p>将DOM树抽象成一个js对象，映射真实DOM的JS对象，这个对象就是Virtual DOM。在项目初始化时，DOM还不存在，根据代码（JSX，template）一个新的virtual DOM会被创建并且应用到真实的DOM上，并且将这个virtual Dom保留下来。当元素状态产生变化时，new virtual dom会重新创建并且和之前保存下来的old virtual dom进行比较，将差别应用在真实的DOM上(patch)，保留new virtual dom覆盖旧的。<br>virtual Dom本质上是一个嵌套着数组的原生对象（不同框架的vnode事例结构是不一样的，以vue为例）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//源码文件：vue/types/vnode.d.ts</span><br><span class="line">export interface VNode &#123;</span><br><span class="line">  tag?: string; //当前节点的标签名称</span><br><span class="line">  data?: VNodeData; //当前节点的数据对象</span><br><span class="line">  children?: VNode[]; //子节点</span><br><span class="line">  text?: string; //当前节点的文本，一版文本节点或是注释节点会有该属性</span><br><span class="line">  elm?: Node; //当前虚拟节点对应的真实的dom节点</span><br><span class="line">  ns?: string;</span><br><span class="line">  context?: Vue;</span><br><span class="line">  key?: string | number;</span><br><span class="line">  componentOptions?: VNodeComponentOptions;</span><br><span class="line">  componentInstance?: Vue;</span><br><span class="line">  parent?: VNode;</span><br><span class="line">  raw?: boolean;</span><br><span class="line">  isStatic?: boolean;</span><br><span class="line">  isRootInsert: boolean;</span><br><span class="line">  isComment: boolean;</span><br><span class="line">&#125;</span><br><span class="line">export interface VNodeData &#123;</span><br><span class="line">  key?: string | number;</span><br><span class="line">  slot?: string;</span><br><span class="line">  scopedSlots?: &#123; [key: string]: ScopedSlot &#125;;</span><br><span class="line">  ref?: string;</span><br><span class="line">  tag?: string;</span><br><span class="line">  staticClass?: string;</span><br><span class="line">  class?: any;</span><br><span class="line">  staticStyle?: &#123; [key: string]: any &#125;;</span><br><span class="line">  style?: Object[] | Object;</span><br><span class="line">  props?: &#123; [key: string]: any &#125;;</span><br><span class="line">  attrs?: &#123; [key: string]: any &#125;;</span><br><span class="line">  domProps?: &#123; [key: string]: any &#125;;</span><br><span class="line">  hook?: &#123; [key: string]: Function &#125;;</span><br><span class="line">  on?: &#123; [key: string]: Function | Function[] &#125;;</span><br><span class="line">  nativeOn?: &#123; [key: string]: Function | Function[] &#125;;</span><br><span class="line">  transition?: Object;</span><br><span class="line">  show?: boolean;</span><br><span class="line">  inlineTemplate?: &#123;</span><br><span class="line">    render: Function;</span><br><span class="line">    staticRenderFns: Function[];</span><br><span class="line">  &#125;;</span><br><span class="line">  directives?: VNodeDirective[];</span><br><span class="line">  keepAlive?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>React是使用JSX（js + xml）语法实现vitual dom的生成，而vue是通过template模版的方式实现的。</p>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>当比较新旧的virtual dom时，我们可以抽象成两棵树的比较。在diff的时候不考虑DOM节点的跨级移动(JS 操作DOM很少出现跨级的情况），只在同一级上进行比较。<br><!-- 图片 --><br>vue的diff位于vue/src/core/vdom/patch.js文件中，该算法来源于snabbdom，复杂度为O(n)。<br>重要的方法：<br>patch()—因为真正的patch算法是patchVnode()来实现的, patchVnode中更新子节点的算法其实是在updateChildren()函数中实现的</p>
<p>然后将差异反应到DOM树上（也就是patch），特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM（React则是将更新放入队列后集中处理），朋友们会问这样做性能很差吧？实际上现代浏览器对这样的DOM操作做了优化，并无差别。</p>
<p>Vue的diff算法与动态规划算法中的经典案例“计算a到b的最小编辑距离”看上去有些相似，实际完全不同，Vue的diff相对来说轻量很多，它使用了oldStartIdx，oldEndIdx，newStartIdx，newEndIdx四个指针进行循环比较，复杂度从O(n * m) 变成了O(max(m, n))</p>
<h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>因为组件与组件之间可以存在嵌套关系，所以组件本身的DOM也会遵循Virtual DOM机制。<br>如果不是同一类型的组件，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。</p>
<p>对于同一类型的组件：<br>React： 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制；<br>Vue：<br>组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了shouldComponentUpdate，更快地计算出Virtual DOM的差异，节省大量的 diff 运算时间，决定是否需要重新渲染整个组建树，Vue将此视为默认的优化。</p>
<p>虽然两个组件的DOM可能完全相似，但是这种情况就没有必要创建两个组件，React官方认为不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的，因此他们毅然决然的采用了上述component diff策略，即使可能存在一定的性能误差。</p>
<h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</p>
<p>参考文档： <a href="https://segmentfault.com/a/1190000008291645" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008291645</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/18/不同框架Virtual-DOM/" data-id="cjnpsydd5000mbmkjpj2nhk99" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何做inception" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/10/如何做inception/" class="article-date">
  <time datetime="2018-07-10T07:40:14.000Z" itemprop="datePublished">2018-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/10/如何做inception/">如何做inception</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过这篇文章大致了解一下inception是什么、inception的准备、产品愿景梳理、用户画像、用户体验地图、How Might We、业务全景图、用户故事拆分估点、产品演进路线、inception汇报等多个环节。</p>
<h3 id="什么是Inception？"><a href="#什么是Inception？" class="headerlink" title="什么是Inception？"></a>什么是Inception？</h3><p>我们了解inception原意是开始、开端，还有一部电影《盗梦空间》也叫Inception，那究竟什么是Inception？项目启动之初，进入客户的梦境中，捕获它们最真实的想法，进行整理、分析，形成计划。Inception理念：和客户在一起，设计透明，打破技术壁垒，传播创新文化。</p>
<img src="/2018/07/10/如何做inception/inception.jpg">
<p>Inception精力的几个阶段 Discover =》 Define =》 Design =》 Deliver 双菱形，是一个不断发散、收敛的过程</p>
<h3 id="Inception准备"><a href="#Inception准备" class="headerlink" title="Inception准备"></a>Inception准备</h3><p>正式的inception开始之前是需要大量准备工作的。除此之外还要明确不同角色在准备阶段的职责是什么。<br><img src="/2018/07/10/如何做inception/inception准备.jpg"><br><img src="/2018/07/10/如何做inception/inception准备1.jpg"></p>
<h3 id="产品愿景"><a href="#产品愿景" class="headerlink" title="产品愿景"></a>产品愿景</h3><p>分成4个小组，分别采访不同的角色，以电梯演讲的方式归纳总结出产品的愿景。<br><img src="/2018/07/10/如何做inception/电梯演讲.jpg"></p>
<h3 id="人物画像"><a href="#人物画像" class="headerlink" title="人物画像"></a>人物画像</h3><p>识别出具有相同特征的人群，归纳出每类人的特点、期望、动机、痛点。<br></p>
<h3 id="用户体验地图"><a href="#用户体验地图" class="headerlink" title="用户体验地图"></a>用户体验地图</h3><p>Design thinking关心人们在不同时间、不同场景下如何使用。用户画像加上不同场景结合用户心情曲线就产生了用户体验地图。<br><img src="/2018/07/10/如何做inception/用户体验地图.jpg"></p>
<h3 id="How-Might-We"><a href="#How-Might-We" class="headerlink" title="How Might We"></a>How Might We</h3><p>通过上面的用户体验地图找出用户的的痛点，大家一起考虑各种解决方案。要考虑到各种可能性，不要太过细节的解决方案，也不要太过宽泛。</p>
<h3 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型"></a>产品原型</h3><p>根据HOW MIGHT WE得出的解决方案，画出产品的原型。<br><img src="/2018/07/10/如何做inception/产品原型.jpg"></p>
<h3 id="业务全景图"><a href="#业务全景图" class="headerlink" title="业务全景图"></a>业务全景图</h3><p>常用的业务场景图的梳理方式有：角色类型、业务流程、操作方式。</p>
<img src="/2018/07/10/如何做inception/业务全景图.png">
<h3 id="用户故事拆分-amp-产品演进图"><a href="#用户故事拆分-amp-产品演进图" class="headerlink" title="用户故事拆分&amp;产品演进图"></a>用户故事拆分&amp;产品演进图</h3><p>在这个阶段需要根据上面的业务场景图，结合技术架构、技术选型等等做用户故事拆分、工作量评估、优先级排列，形成迭代计划、交付计划。</p>
<h3 id="Inception汇报"><a href="#Inception汇报" class="headerlink" title="Inception汇报"></a>Inception汇报</h3><p>四个小组依次做了最后的inception汇报，为两天的培训提交了完美的答卷。<br>Inception的产出包括：</p>
<ul>
<li>项目愿景</li>
<li>用户画像</li>
<li>用户故事地图</li>
<li>原型图</li>
<li>视觉风格</li>
<li>技术架构、技术栈、技术限制等</li>
<li>测试策略、安全策略</li>
<li>项目管理</li>
<li>交付计划</li>
<li>沟通计划</li>
<li>产品演进图</li>
<li>用户故事列表</li>
<li>风险依赖等等</li>
<li>……………………</li>
</ul>
<p>最后来一条inception生存指南：了解客户现场环境，理清人物之间关系</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/10/如何做inception/" data-id="cjnpsydd8000sbmkj5i1pcfvl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/inception/">inception</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/JS-闭包/" class="article-date">
  <time datetime="2018-05-10T07:22:36.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/JS-闭包/">JS 闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.codeceo.com/article/javascript-closure-learn.html" target="_blank" rel="noopener">http://www.codeceo.com/article/javascript-closure-learn.html</a><br>闭包的特性：</p>
<ul>
<li>函数嵌套函数</li>
<li>函数内部可以应用外部函数的参数、变量</li>
<li>外部函数的参数和变量不会被垃圾回收机制回收</li>
</ul>
<p>闭包指“有权限访问另一个函数作用域中变量”的函数。创建闭包的常见方式是在一个函数中创建另一个函数，在另一个函数中访问这个函数的局部变量。<br>缺点：常驻内存，增大内存的使用量，使用不当造成内存泄漏。一般函数执行完毕，局部活动对象就被销毁，内存中仅仅保存全局作用域，但是闭包不会。</p>
<p>从常用函数到闭包</p>
<h3 id="全局变量累加"><a href="#全局变量累加" class="headerlink" title="全局变量累加"></a>全局变量累加</h3><p>实现变量的累加，我们首先想到的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var a = 1;</span><br><span class="line">function abc()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        alert(a);</span><br><span class="line">&#125;</span><br><span class="line">abc();              //2</span><br><span class="line">abc();            //3</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>但是这个问题是我们使用的是全局变量，要做到避免全局变量的污染,使用局部变量</p>
<p>###局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">function abc()&#123;</span><br><span class="line">        var a = 1;</span><br><span class="line">        a++;</span><br><span class="line">        alert(a);</span><br><span class="line">&#125;</span><br><span class="line">abc();                       //2</span><br><span class="line">abc();                    //2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>怎么做到既用局部变量a又能实现变量累加</p>
<h3 id="局部变量累加"><a href="#局部变量累加" class="headerlink" title="局部变量累加"></a>局部变量累加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function outer()&#123;</span><br><span class="line">        var x=10;</span><br><span class="line">        return function()&#123;             //函数嵌套函数</span><br><span class="line">                x++;</span><br><span class="line">                alert(x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">var y = outer();              //外部函数赋给变量y;</span><br><span class="line">y();                 //y函数调用一次，结果为11，相当于outer()()；</span><br><span class="line">y();                //y函数调用第二次，结果为12，实现了累加</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="函数声明以及函数表达式"><a href="#函数声明以及函数表达式" class="headerlink" title="函数声明以及函数表达式"></a>函数声明以及函数表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function outer()&#123;</span><br><span class="line">        var x=10;</span><br><span class="line">        return function()&#123;             //函数嵌套函数</span><br><span class="line">                x++;</span><br><span class="line">                alert(x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个函数的声明，通过function关键字声明一个函数。可以通过”()”将声明编程表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = (function()&#123;</span><br><span class="line">    var x=10;</span><br><span class="line">    return function()&#123;             //函数嵌套函数</span><br><span class="line">            x++;</span><br><span class="line">            alert(x);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)()</span><br><span class="line">//a 为外部匿名函数的返回值，也是一个函数</span><br><span class="line"></span><br><span class="line">a() // 11</span><br><span class="line">a() //12</span><br></pre></td></tr></table></figure></p>
<p>##使用闭包的好处</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/10/JS-闭包/" data-id="cjnpsydd2000hbmkjlcxrnwk8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-响应式编程RxJS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/响应式编程RxJS/" class="article-date">
  <time datetime="2018-04-24T02:23:34.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/响应式编程RxJS/">响应式编程-Observable详细解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h2><p>RxJS 是响应式编程的库，通过使用observables，方便的构造出异步的或是基于事件的程序<br>RXJS是基于观察者模式和迭代器模式以函数式编程的思维实现的，先提前了解一下什么是响应式编程、观察者模式、迭代器模式？</p>


<h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>响应式编程就是异步数据流交互的编程范式。 事件总线（event buses）或一些典型的点击事件本质上是一个异步的事件流，这样你可以观察他的变化并且做出一些反应。<br>除了典型的鼠标事件（点击、悬停等），你可以给任何事物创建数据流，任何东西也可以成为数据流，例如变量、用户输入、缓存等等，微博订阅也可以想象成和点击事件一样的数据流，你可以监听这样的数据流，并做出相应的反应。<br><img src="/2018/04/24/响应式编程RxJS/RxJS1.png"><br>数据流是整个响应式编程体系中的核心。</p>
<h2 id="设计模式-观察者模式-amp-amp-迭代器模式"><a href="#设计模式-观察者模式-amp-amp-迭代器模式" class="headerlink" title="设计模式-观察者模式&amp;&amp;迭代器模式"></a>设计模式-观察者模式&amp;&amp;迭代器模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>又叫发布订阅模式，定义一对多的关系，如果主题对象的状态发生变化就会自动通知所有订阅者，让他们自己做更新；如果观察者取消订阅，那么将不会收到任何主题的通知消息<br><img src="/2018/04/24/响应式编程RxJS/RxJS2.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//subject类定义（被观察者）</span><br><span class="line">class Subject &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.observerCollection = []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  registerObserver(observer) &#123;//观察者订阅消息</span><br><span class="line">    this.observerCollection.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  unregisterObserver(observer) &#123;//观察者取消订阅</span><br><span class="line">    int index = this.oberverCollection.indexOf(observer);</span><br><span class="line">    if(index &gt;= 0) this.observerCollection.splice(index, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  notifyObservers() &#123;//当状态发生变化时，通知所有的订阅者</span><br><span class="line">    this.observerCollection.forEach(observer =&gt; observer.notify())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//观察者</span><br><span class="line">class Observer &#123;</span><br><span class="line">  constrcutor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  notify () &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; has been notified`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用案例</span><br><span class="line"></span><br><span class="line">let subject = new Subject();</span><br><span class="line">let observerA = new Observer(&quot;observer A&quot;);</span><br><span class="line">let observerB = new Observer(&quot;observer B&quot;);</span><br><span class="line"></span><br><span class="line">subject.registerObserver(observerA)//注册观察者A</span><br><span class="line">subject.registerObserver(observerB)//注册观察者B</span><br><span class="line"></span><br><span class="line">subject.notifyObservers();//发布消息给所有的观察者</span><br><span class="line">subject.unregisterObserver(observerA);//移除观察者A</span><br></pre></td></tr></table></figure></p>
<p>模式的优点：</p>
<ul>
<li>支持简单的广播通信，自动通知所有订阅者</li>
<li>主题与观察者之间的关系可以单独拓展以及重用</li>
</ul>
<p>劣势：</p>
<ul>
<li>由于是一对多的关系，如果订阅者过多，通知所有订阅者将会花费很长时间</li>
<li>主题和观察之间如果有循环依赖，那么会触发循环调用，可能导致系统崩溃。</li>
</ul>
<p>常见的观察者模式的例子就是给DOM对象添加监听事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&apos;button&apos;&gt;OK&lt;/button&gt;</span><br><span class="line">function clickHandle(event) &#123;</span><br><span class="line">  console.log(&apos;用户点击确认按钮&apos;)</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&apos;#button&apos;).addEventListener(&apos;click&apos;, clickHandle);</span><br></pre></td></tr></table></figure>
<p>通过addEventListener监听button对象的click事件。当用户点击按钮时，会自动执行clickHandle</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>它提供一种方法能够顺序访问一个聚合对象中各个元素，又不需要暴露该对象的内部表示。Javascript中像Array，Set等都属于内置的可迭代类型。可以通过iterator方法来获取一个迭代对象。调用迭代对象的next方法获取一个元素对象(包含两个属性value、 done)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var iterable = [1, 2]</span><br><span class="line">var iterator = iterable[Symbol.iterator]();</span><br><span class="line">iterator.next(); //&#123;value: 1, done: false&#125;</span><br><span class="line">iterator.next(); //&#123;value: 2, done: false&#125;</span><br><span class="line">iterator.next(); //&#123;value: undefined, done: true&#125; //value是返回值，done为true表示已经到达最后</span><br><span class="line"></span><br><span class="line">//遍历迭代器</span><br><span class="line">var iterable = [1, 2]</span><br><span class="line">var iterator = iterable[Symbol.iterator]();//ES6可以通过Symbol.iterator来创建可迭代对象的内部迭代器</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">  let result;</span><br><span class="line">  try &#123;</span><br><span class="line">    result = iterator.next(); //获取下一个元素</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    handleError(error)//错误处理</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if(result.done) &#123;</span><br><span class="line">    handleCompleted(); //已完成</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  doSth(result.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应三种情况：获取下一个值、已完成（无更多值）、错误处理</p>
<h2 id="RxJS-观察者-迭代器"><a href="#RxJS-观察者-迭代器" class="headerlink" title="RxJS = 观察者+迭代器"></a>RxJS = 观察者+迭代器</h2><p>RxJS是基于观察者模式和迭代器模式以函数式编程的思维实现的。<br>RxJS中含有两个基本的概念：Observables（被观察者，是一个值或者事件流的集合）、Observer（观察者）</p>
<p>订阅： Observer通过Observable提供的subscribe()方法订阅Observable</p>
<p>发布： Observable通过回调Observer next()方法向Observer发布消息</p>
<h3 id="Observable："><a href="#Observable：" class="headerlink" title="Observable："></a>Observable：</h3><ul>
<li>Creating Observables<ul>
<li>可以使用Rx.Observable.create或者是Create Operate(下文介绍)来创建</li>
</ul>
</li>
<li>Subscribing to Observables<ul>
<li>订阅Observable，接受一个Observer对象（这个对象包含next、error、completed方法）作为参数</li>
</ul>
</li>
<li>Execution Observable<ul>
<li>The code inside <b>Observable.create(function subscribe(observer) {…}) </b>represents an “Observable execution”</li>
<li>执行发布next/error/complete消息通知给Observer</li>
</ul>
</li>
<li>Disposing Observable Executions<ul>
<li>返回一个unsubscribe函数，用于取消订阅（Observable Executions可能是无穷的，Observer想要终止执行，就需要取消订阅）</li>
</ul>
</li>
</ul>
<h3 id="Observer："><a href="#Observer：" class="headerlink" title="Observer："></a>Observer：</h3><p>RxJS中，Observer是一个包含3个方法的对象, 它消费Observable发布的数据。当Observable触发事件时，便会自动调用观察者的对应的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Observer = &#123;</span><br><span class="line">  next(value) &#123;  //处理值，每当Observable发送新值的时候，next方法会被调用  &#125;</span><br><span class="line">  error(err) &#123;  //处理异常 ，当 Observable 内发生错误时，error 方法就会被调用   &#125;</span><br><span class="line">  completed() &#123;//处理已经完成状态， 当 Observable 数据终止后，complete 方法会被调用。在调用 complete 方法之后，next 方法就不会再次被调用&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Observer也可以只包含部分回调函数，如果Observer不包含某些函数，Observable仍然会正常执行，只不过这个通知会被忽略，因为Observer没有对应的回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable</span><br><span class="line">    .create(function(observer) &#123;</span><br><span class="line">            observer.next(&apos;Semlinker&apos;);</span><br><span class="line">            observer.next(&apos;Lolo&apos;);</span><br><span class="line">            observer.complete();</span><br><span class="line">            observer.next(&apos;not work&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">// 创建一个观察者</span><br><span class="line">var observer = &#123;</span><br><span class="line">    next: function(value) &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: function() &#123;</span><br><span class="line">        console.log(&apos;complete&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 订阅已创建的observable对象</span><br><span class="line">observable.subscribe(observer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//控制台输出</span><br><span class="line">Semlinker</span><br><span class="line">Lolo</span><br><span class="line">complete</span><br></pre></td></tr></table></figure>
<ul>
<li>complete方法执行后，next会失效。</li>
<li>另外观察者可以只包含一个next方法；</li>
<li>当Observable是一个无限序列的时候，例如click，这种场景下，complete方法永远不会被调用。</li>
</ul>
<h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>什么是subscription？它是一个对象，一种随时可以丢弃的资源，有一个unsubscrible方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable.interval(1000);</span><br><span class="line">var subscription = observable.subscribe(x =&gt; console.log(x));</span><br><span class="line">// Later:</span><br><span class="line">// This cancels the ongoing Observable execution which</span><br><span class="line">// was started by calling subscribe with an Observer.</span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>什么是subject？ rxjs subject是一种特殊类型的Observable，能够将值多路广播给多个Observers。普通的Observable是单路广播</p>
<ul>
<li><p>多播（make multiple Observers see the same Observable execution）</p>
</li>
<li><p>单播（each Observer拥有独立的属于自己Observable execution）</p>
</li>
</ul>
<p>每个Subject是一个Observable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.Subject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(1);//对于subject来说，它发布值的时候并不会invoke a new execution，shared execution</span><br><span class="line">subject.next(2);</span><br></pre></td></tr></table></figure>
<p>从Observer的视角来看，它并不清楚Observable execution是来源于多路广播还是单路广播。</p>
<p>一个Subject也是一个Observer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.Subject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var observable = Rx.Observable.from([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">observable.subscribe(subject);</span><br></pre></td></tr></table></figure>
<p>Subject将单路传播的Observable execution变为多路传播，也是唯一的方式</p>
<h2 id="RxJS-Operators操作"><a href="#RxJS-Operators操作" class="headerlink" title="RxJS Operators操作"></a>RxJS Operators操作</h2><p>Operator也是一个函数，它接受一个Observable对象，返回一个新的Observable对象。<br>Observable支持operator链式结构</p>
<p>Observable - Create Operator<br>常用的操作符，用来创建Observable对象： create、of、from、fromEvent、fromPromise、empty、never、throw、interval、timer</p>
<p>value producing operator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.of(&apos;Semlinker&apos;, &apos;Lolo&apos;);</span><br><span class="line"></span><br><span class="line">source.subscribe(&#123;</span><br><span class="line">    next: function(value) &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: function() &#123;</span><br><span class="line">        console.log(&apos;complete!&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//控制台输出结果：</span><br><span class="line">Semlinker</span><br><span class="line">Lolo</span><br><span class="line">complete</span><br></pre></td></tr></table></figure>
<p>Observable是延迟计算、push体系的多值集合。</p>
<h2 id="Push-amp-amp-Pull"><a href="#Push-amp-amp-Pull" class="headerlink" title="Push &amp;&amp; Pull"></a>Push &amp;&amp; Pull</h2><p>push和pull是数据生产者和消费者两种不同的交流方式</p>
<h3 id="什么是”pull”？"><a href="#什么是”pull”？" class="headerlink" title="什么是”pull”？"></a>什么是”pull”？</h3><p>“拉”的体系中，消费者决定何时从生产者那里获取数据，生产者本身并不知道什么时候数据会被发送给消费者<br>每一个Javascript函数都是一个拉的体系，函数是生产者，调用函数的则是消费者，它消费函数的返回值数据</p>
<h3 id="什么是”push”？"><a href="#什么是”push”？" class="headerlink" title="什么是”push”？"></a>什么是”push”？</h3><p>在”推”的体系中，生产者决定何时发送数据给消费者，消费者在接收数据之前并不知道它将要接收数据<br>Promise 是JS中常见的”推”体系，一个Promise（生产者）发送一个resolve value（成功状态的值）来执行回调函数（消费者）。Promise决定着何时才推送数据到回调函数<br>RxJs引入的Observable（被观察者），是”推”的体系。Observable是一个产生多值的生产者，当产生新数据时，会主动推送给消费者（Observer）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">生产者</th>
<th style="text-align:center">消费者</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pull</td>
<td style="text-align:center">收到请求的时候再产生数据</td>
<td style="text-align:center">决定何时请求数据</td>
<td style="text-align:center">JS Function</td>
</tr>
<tr>
<td style="text-align:center">push</td>
<td style="text-align:center">按自己需求主动产生数据</td>
<td style="text-align:center">对接收的数据进行处理</td>
<td style="text-align:center">Promise/Observable</td>
</tr>
</tbody>
</table>
<h2 id="Single-amp-amp-Multiple"><a href="#Single-amp-amp-Multiple" class="headerlink" title="Single &amp;&amp; Multiple"></a>Single &amp;&amp; Multiple</h2><p>单值和多值是Observable和Function的不同之一。<br>随着时间的推移，Observables 能够发布多个值，但是函数并不能</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">消费者 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">single</td>
<td style="text-align:center">只能发布一个值</td>
<td style="text-align:center">JS Function/Promise</td>
</tr>
<tr>
<td style="text-align:center">multiple</td>
<td style="text-align:center">能够发布多个值</td>
<td style="text-align:center">Observable/Iterator </td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return 1;</span><br><span class="line">  return 2; //will never happen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function只能返回一个值，但是Observables：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var foo = Rx.Observable.create(function (observer) &#123;</span><br><span class="line">  console.log(&apos;Hello&apos;);</span><br><span class="line">  observer.next(42);</span><br><span class="line">  observer.next(100); // &quot;return&quot; another value</span><br><span class="line">  observer.next(200); // &quot;return&quot; yet another</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;before&apos;);</span><br><span class="line">foo.subscribe(function (x) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;after&apos;);</span><br><span class="line">//output</span><br><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure>
<p>Observables 能够同步的发布多个值。</p>
<h2 id="延迟计算-amp-渐进式取值"><a href="#延迟计算-amp-渐进式取值" class="headerlink" title="延迟计算 &amp; 渐进式取值"></a>延迟计算 &amp; 渐进式取值</h2><h3 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h3><p>所有的Observable对象只有等到订阅后才会执行，如果没有订阅就不会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var source = RX.observable.from([1,2,3,4]);</span><br><span class="line">var result = source.map(x =&gt; x + 1);</span><br></pre></td></tr></table></figure>
<p>result 对象未被订阅，所以不会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var x = foo(); //=&gt; output: hello</span><br></pre></td></tr></table></figure>
<p>如果不调用函数foo，那么console.log并不会执行。<br>Function和Observable都是延迟计算。订阅Observable就如同调用Function一样。</p>
<h3 id="渐进式取值"><a href="#渐进式取值" class="headerlink" title="渐进式取值"></a>渐进式取值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var source = [1, 2, 3, 4];</span><br><span class="line">var example = source</span><br><span class="line">                .filter(x =&gt; x % 2 == 0)//[2, 4]</span><br><span class="line">                .map(x =&gt; x + 1)// [3, 5]</span><br></pre></td></tr></table></figure>
<p>数组操作符filter、map完整执行之后才会返回一个新的数组、进行下一步计算（先对整个数组进行filter，得到完整结果之后才会进行map）</p>
<p>虽然Observable运算符每次会返回一个新的Observable对象，但是每个元素都是渐进式获取的，且每个元素都会经过操作符链的运算后才会输出，不会像数组那样，每个阶段都得到完整的运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var source = Rx.Observable.from([1,2,3,4,5]);</span><br><span class="line">var example = source</span><br><span class="line">              .filter(x =&gt; x % 2 === 0)</span><br><span class="line">              .map(x =&gt; x + 1)</span><br><span class="line"></span><br><span class="line">example.subscribe(console.log);</span><br></pre></td></tr></table></figure>
<ul>
<li>source发出1，执行filter被过滤掉</li>
<li>source发出2，执行filter， 执行map处理成3，执行console</li>
<li>source发出3， 执行filter过滤掉</li>
<li>source发出4，执行filter，执行map被处理成5，执行console</li>
<li>source发出5， 执行filter过滤掉</li>
</ul>
<h3 id="Observable-vs-Promise"><a href="#Observable-vs-Promise" class="headerlink" title="Observable vs Promise"></a>Observable vs Promise</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">Single（单值）</th>
<th style="text-align:center">Multiple（多值）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pull</td>
<td style="text-align:center">Function（函数）</td>
<td style="text-align:center">Iterator（遍历器）</td>
</tr>
<tr>
<td style="text-align:center">push</td>
<td style="text-align:center">Promise</td>
<td style="text-align:center">Observable</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">比较</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Function</td>
<td style="text-align:left">延迟计算，当被调用的时候同步返回一个单值</td>
</tr>
<tr>
<td style="text-align:left">Iterator</td>
<td style="text-align:left">延迟计算，同步返回零个或是无限多个值</td>
</tr>
<tr>
<td style="text-align:left">Promise</td>
<td style="text-align:left">可能返回单个值或是不返回值</td>
</tr>
<tr>
<td style="text-align:left">Observable</td>
<td style="text-align:left">延迟计算，从被调用开始同步或是异步的返回零个到无限多的值</td>
</tr>
</tbody>
</table>
<ul>
<li>Promise<ul>
<li>返回单个值</li>
<li>不可取消的</li>
</ul>
</li>
<li>Observable<ul>
<li>可以随时间的推移发出多个值</li>
<li>可以取消的（取消订阅）</li>
<li>支持operator，例如map、filter、reduce等</li>
<li>延迟执行，只有当订阅是才会执行</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/响应式编程RxJS/" data-id="cjnpsydda000xbmkj1hieh700" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/响应式/">响应式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模式/">模式</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mock/">Mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TDD/">TDD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inception/">inception</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/可视化/">可视化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/响应式/">响应式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷/">敏捷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷实践/">敏捷实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模式/">模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/TDD/" style="font-size: 10px;">TDD</a> <a href="/tags/inception/" style="font-size: 10px;">inception</a> <a href="/tags/可视化/" style="font-size: 10px;">可视化</a> <a href="/tags/响应式/" style="font-size: 10px;">响应式</a> <a href="/tags/敏捷/" style="font-size: 10px;">敏捷</a> <a href="/tags/敏捷实践/" style="font-size: 10px;">敏捷实践</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/模式/" style="font-size: 10px;">模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/26/领导力培训/">领导力培训</a>
          </li>
        
          <li>
            <a href="/2018/09/13/security-knowledge/">security knowledge</a>
          </li>
        
          <li>
            <a href="/2018/08/08/商业模式/">商业模式 </a>
          </li>
        
          <li>
            <a href="/2018/08/07/shell-script/">shell script</a>
          </li>
        
          <li>
            <a href="/2018/08/07/css-new-properties-introduction/">css new properties introduction</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Haiyan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>